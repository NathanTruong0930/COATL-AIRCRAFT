//Same as above with website testing
#include <SPI.h>
#include <WiFi.h>
#include <WebServer.h>

// === WiFi Configuration ===
const char* ssid = "EA";
const char* password = "123456Ee";

// === Web server on port 80 ===
WebServer server(80);

// ADG212 control pins
#define ROUTE1_PIN 9
#define ROUTE2_PIN 8
#define ROUTE3_PIN 7

// MAX1032 SPI configuration
#define CS_PIN     17
#define SPI_SCK    36
#define SPI_MOSI   35
#define SPI_MISO   37

// ADC settings
#define V_REF             4.098
#define ADC_RANGE_BYTE    0b10000100
#define MODE_CONTROL_BYTE 0b10000000

// Data tracking
int currentRoute = 1;
unsigned long lastRouteSwitch = 0;
unsigned long lastADCRead = 0;
uint16_t adcRaw = 0;
float voltage = 0.0;

// === Web Page Handler ===
void handleRoot() {
  String html = "<html><head><meta http-equiv='refresh' content='1'/>"
                "<title>EDA Monitor</title></head><body>"
                "<h2>Electrostatic Dust Analyzer Status</h2>"
                "<p><b>Active Route:</b> " + String(currentRoute) + "</p>"
                "<p><b>ADC Raw:</b> " + String(adcRaw) + "</p>"
                "<p><b>Voltage:</b> " + String(voltage, 4) + " V</p>"
                "</body></html>";
  server.send(200, "text/html", html);
}

void setup() {
  Serial.begin(115200);

  // Route control setup
  pinMode(ROUTE1_PIN, OUTPUT);
  pinMode(ROUTE2_PIN, OUTPUT);
  pinMode(ROUTE3_PIN, OUTPUT);
  disableAllRoutes();
  enableRoute(1);

  // SPI init
  pinMode(CS_PIN, OUTPUT);
  digitalWrite(CS_PIN, HIGH);
  SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI);
  SPI.beginTransaction(SPISettings(500000, MSBFIRST, SPI_MODE0));
  configureADC();

  // WiFi init
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500); Serial.print(".");
  }
  Serial.println("\nWiFi connected, IP address: " + WiFi.localIP().toString());

  // Web server routes
  server.on("/", handleRoot);
  server.begin();
  Serial.println("Web server started");
}

void loop() {
  unsigned long now = millis();
  server.handleClient();

  // Route switching
  if (now - lastRouteSwitch >= 20000) {
    currentRoute++;
    if (currentRoute > 3) currentRoute = 1;
    disableAllRoutes();
    enableRoute(currentRoute);
    Serial.print("Switched to ROUTE "); Serial.println(currentRoute);
    lastRouteSwitch = now;
  }

  // ADC reading
  if (now - lastADCRead >= 1000) {
    adcRaw = readMAX1032();
    voltage = ((adcRaw / 16383.0) - 0.5) * (3 * V_REF);
    Serial.print("ADC Raw: "); Serial.print(adcRaw);
    Serial.print(" | Voltage: "); Serial.print(voltage, 4);
    Serial.print(" V | Active Route: "); Serial.println(currentRoute);
    lastADCRead = now;
  }
}

void enableRoute(int route) {
  digitalWrite(ROUTE1_PIN, route == 1 ? HIGH : LOW);
  digitalWrite(ROUTE2_PIN, route == 2 ? HIGH : LOW);
  digitalWrite(ROUTE3_PIN, route == 3 ? HIGH : LOW);
}

void disableAllRoutes() {
  digitalWrite(ROUTE1_PIN, LOW);
  digitalWrite(ROUTE2_PIN, LOW);
  digitalWrite(ROUTE3_PIN, LOW);
}

void configureADC() {
  digitalWrite(CS_PIN, LOW);
  SPI.transfer(MODE_CONTROL_BYTE);
  digitalWrite(CS_PIN, HIGH);
  delayMicroseconds(10);

  digitalWrite(CS_PIN, LOW);
  SPI.transfer(ADC_RANGE_BYTE);
  digitalWrite(CS_PIN, HIGH);
  delayMicroseconds(100);
}

uint16_t readMAX1032() {
  uint8_t response[3] = {0};
  digitalWrite(CS_PIN, LOW);
  SPI.transfer(MODE_CONTROL_BYTE);
  response[0] = SPI.transfer(0x00);
  response[1] = SPI.transfer(0x00);
  response[2] = SPI.transfer(0x00);
  digitalWrite(CS_PIN, HIGH);
  return (((response[1] << 8) | response[2]) >> 2) & 0x3FFF;
}
